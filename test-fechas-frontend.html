<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test de Fechas Frontend</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #0490C8;
            margin-bottom: 15px;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid #17a2b8;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background: #0490C8;
            color: white;
        }
        .summary {
            font-size: 1.2em;
            font-weight: bold;
            padding: 15px;
            text-align: center;
            border-radius: 8px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>🧪 Test de Manejo de Fechas - Frontend CitaYA</h1>
    
    <div id="results"></div>

    <script>
        // Simular las funciones del frontend
        
        // ===== De utils/format.ts =====
        function parseDateLocal(dateString) {
            const [year, month, day] = dateString.split('-').map(Number);
            return new Date(year, month - 1, day, 0, 0, 0, 0);
        }

        function toDate(date) {
            if (date instanceof Date) {
                return date;
            }
            
            if (typeof date === 'string') {
                // Extract just the date part if it's an ISO datetime string
                // Handles: "2024-10-23", "2024-10-23T00:00:00", "2024-10-23T00:00:00.000Z"
                const dateMatch = date.match(/^(\d{4}-\d{2}-\d{2})/);
                if (dateMatch) {
                    return parseDateLocal(dateMatch[1]);
                }
            }
            
            // Fallback to Date constructor (for other datetime formats)
            return new Date(date);
        }

        function formatDateInput(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // ===== De CalendarView.tsx =====
        function formatDateCalendar(date) {
            if (typeof date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
                return date;
            }
            const d = date instanceof Date ? date : new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // ===== Tests =====
        const results = [];
        let totalTests = 0;
        let passedTests = 0;

        function test(description, testFn) {
            totalTests++;
            try {
                const result = testFn();
                if (result.pass) {
                    passedTests++;
                    results.push({
                        type: 'success',
                        description,
                        details: result.details
                    });
                } else {
                    results.push({
                        type: 'error',
                        description,
                        details: result.details
                    });
                }
            } catch (error) {
                results.push({
                    type: 'error',
                    description,
                    details: `Error: ${error.message}`
                });
            }
        }

        // Test 1: parseDateLocal mantiene el día correcto
        test('parseDateLocal("2024-10-23") mantiene el día 23 en cualquier timezone', () => {
            const fecha = parseDateLocal("2024-10-23");
            const dia = fecha.getDate();
            return {
                pass: dia === 23,
                details: `Día obtenido: ${dia}, Esperado: 23, Timezone: ${Intl.DateTimeFormat().resolvedOptions().timeZone}`
            };
        });

        // Test 2: toDate con string YYYY-MM-DD
        test('toDate("2024-10-23") usa parseDateLocal y mantiene el día', () => {
            const fecha = toDate("2024-10-23");
            const dia = fecha.getDate();
            return {
                pass: dia === 23,
                details: `Día: ${dia}, Fecha completa: ${fecha.toString()}`
            };
        });

        // Test 3: toDate con Date object
        test('toDate(new Date(2024, 9, 23)) devuelve el mismo Date', () => {
            const original = new Date(2024, 9, 23);
            const resultado = toDate(original);
            return {
                pass: resultado === original,
                details: `Es el mismo objeto: ${resultado === original}`
            };
        });

        // Test 4: formatDateInput mantiene el día
        test('formatDateInput(new Date(2024, 9, 23)) retorna "2024-10-23"', () => {
            const fecha = new Date(2024, 9, 23);
            const resultado = formatDateInput(fecha);
            return {
                pass: resultado === "2024-10-23",
                details: `Resultado: "${resultado}", Esperado: "2024-10-23"`
            };
        });

        // Test 5: formatDateCalendar con string
        test('formatDateCalendar("2024-10-23") retorna el mismo string', () => {
            const resultado = formatDateCalendar("2024-10-23");
            return {
                pass: resultado === "2024-10-23",
                details: `Resultado: "${resultado}"`
            };
        });

        // Test 6: formatDateCalendar con Date
        test('formatDateCalendar(new Date(2024, 9, 23)) retorna "2024-10-23"', () => {
            const fecha = new Date(2024, 9, 23);
            const resultado = formatDateCalendar(fecha);
            return {
                pass: resultado === "2024-10-23",
                details: `Resultado: "${resultado}"`
            };
        });

        // Test 7: Ciclo completo - crear fecha local, formatear, parsear de nuevo
        test('Ciclo completo: Date local -> string -> parseDateLocal mantiene el día', () => {
            const fechaOriginal = new Date(2024, 9, 23);
            const fechaString = formatDateInput(fechaOriginal);
            const fechaParseada = parseDateLocal(fechaString);
            
            const diaOriginal = fechaOriginal.getDate();
            const diaParseado = fechaParseada.getDate();
            
            return {
                pass: diaOriginal === diaParseado,
                details: `Original: ${diaOriginal}, Parseado: ${diaParseado}, String intermedio: "${fechaString}"`
            };
        });

        // Test 8: Comparación de fechas
        test('Comparación de fechas: dos fechas con el mismo día son iguales', () => {
            const fecha1 = parseDateLocal("2024-10-23");
            const fecha2 = parseDateLocal("2024-10-23");
            const fecha1Str = formatDateInput(fecha1);
            const fecha2Str = formatDateInput(fecha2);
            
            return {
                pass: fecha1Str === fecha2Str,
                details: `Fecha 1: "${fecha1Str}", Fecha 2: "${fecha2Str}"`
            };
        });

        // Test 9: Diferentes zonas horarias simuladas
        test('Prueba con fecha que causaría problema en UTC-5 (Ecuador)', () => {
            // En Ecuador (UTC-5), "2024-10-23" con new Date() se convertiría a "2024-10-22T19:00:00"
            const fechaString = "2024-10-23";
            const fechaCorrecta = parseDateLocal(fechaString);
            const fechaIncorrecta = new Date(fechaString); // Esto causaría el problema
            
            const diaCorrect = fechaCorrecta.getDate();
            const diaIncorrect = fechaIncorrecta.getDate();
            
            return {
                pass: diaCorrect === 23,
                details: `Con parseDateLocal: día ${diaCorrect} ✓ | Con new Date(): día ${diaIncorrect} ${diaIncorrect !== 23 ? '✗ (problema detectado)' : '✓'}`
            };
        });

        // Test 10: Agrupar citas por fecha (simula lógica de CalendarView)
        test('Agrupar citas por fecha mantiene el día correcto', () => {
            const citas = [
                { id: 1, fecha: "2024-10-23", horaInicio: "09:00" },
                { id: 2, fecha: "2024-10-23", horaInicio: "10:00" },
                { id: 3, fecha: "2024-10-24", horaInicio: "09:00" }
            ];
            
            const grouped = {};
            citas.forEach(cita => {
                const fechaNormalizada = cita.fecha.split('T')[0];
                if (!grouped[fechaNormalizada]) {
                    grouped[fechaNormalizada] = [];
                }
                grouped[fechaNormalizada].push(cita);
            });
            
            const has23 = grouped["2024-10-23"] && grouped["2024-10-23"].length === 2;
            const has24 = grouped["2024-10-24"] && grouped["2024-10-24"].length === 1;
            
            return {
                pass: has23 && has24,
                details: `Citas agrupadas correctamente: 2 en 2024-10-23, 1 en 2024-10-24`
            };
        });

        // Test 11: CrearCitaModal - fecha inicial es hoy
        test('Modal inicializa con fecha de hoy correctamente', () => {
            const hoy = new Date();
            hoy.setHours(0, 0, 0, 0);
            const fechaFormateada = formatDateInput(hoy);
            
            // Verificar que el formato sea correcto
            const regex = /^\d{4}-\d{2}-\d{2}$/;
            
            return {
                pass: regex.test(fechaFormateada),
                details: `Fecha formateada: "${fechaFormateada}", Día: ${hoy.getDate()}`
            };
        });

        // Test 12: Envío al backend
        test('Datos enviados al backend tienen formato correcto', () => {
            const fechaSeleccionada = new Date(2024, 9, 23);
            const dataToSubmit = {
                fecha: formatDateInput(fechaSeleccionada),
                horaInicio: "09:00",
                horaFin: "10:00"
            };
            
            const fechaCorrecta = dataToSubmit.fecha === "2024-10-23";
            const horaCorrecta = /^\d{2}:\d{2}$/.test(dataToSubmit.horaInicio);
            
            return {
                pass: fechaCorrecta && horaCorrecta,
                details: `Fecha: "${dataToSubmit.fecha}", Hora: "${dataToSubmit.horaInicio}"`
            };
        });

        // Test 13: Backend responde con formato ISO completo (con hora UTC)
        test('toDate("2024-10-23T00:00:00.000Z") mantiene el día 23', () => {
            const fechaISO = "2024-10-23T00:00:00.000Z";
            const fecha = toDate(fechaISO);
            const dia = fecha.getDate();
            
            return {
                pass: dia === 23,
                details: `String ISO: "${fechaISO}", Día obtenido: ${dia}, Esperado: 23`
            };
        });

        // Test 14: Backend responde con formato ISO sin Z
        test('toDate("2024-10-23T00:00:00") mantiene el día 23', () => {
            const fechaISO = "2024-10-23T00:00:00";
            const fecha = toDate(fechaISO);
            const dia = fecha.getDate();
            
            return {
                pass: dia === 23,
                details: `String ISO: "${fechaISO}", Día obtenido: ${dia}, Esperado: 23`
            };
        });

        // Test 15: Vista de tabla - format.date() con respuesta del backend
        test('format.date() con fecha ISO del backend muestra día correcto', () => {
            // Simular respuesta del backend con fecha ISO
            const citaDelBackend = {
                id: "123",
                fecha: "2024-10-23T00:00:00.000Z",
                horaInicio: "09:00"
            };
            
            const fechaParseada = toDate(citaDelBackend.fecha);
            const dia = fechaParseada.getDate();
            
            // Simular format.date()
            const formatted = fechaParseada.toLocaleDateString('es-ES', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
            });
            
            return {
                pass: dia === 23,
                details: `Fecha del backend: "${citaDelBackend.fecha}", Día parseado: ${dia}, Formateado: "${formatted}"`
            };
        });

        // Test 16: Problema específico - Ecuador UTC-5 con fecha ISO
        test('Ecuador (UTC-5): "2024-10-23T00:00:00.000Z" NO debe convertirse a día 22', () => {
            const fechaISO = "2024-10-23T00:00:00.000Z";
            
            // Con toDate() corregido
            const fechaCorrecta = toDate(fechaISO);
            const diaCorrectoParseado = fechaCorrecta.getDate();
            
            // Con new Date() (método incorrecto - para comparación)
            const fechaIncorrecta = new Date(fechaISO);
            const diaIncorrecto = fechaIncorrecta.getDate();
            
            return {
                pass: diaCorrectoParseado === 23,
                details: `Con toDate(): día ${diaCorrectoParseado} ✓ | Con new Date(): día ${diaIncorrecto} ${diaIncorrecto !== 23 ? '✗ (problema evitado)' : '✓'}`
            };
        });

        // Test 17: Array de citas del backend
        test('Array de citas del backend se parsea correctamente', () => {
            const citasDelBackend = [
                { id: "1", fecha: "2024-10-23T00:00:00.000Z", horaInicio: "09:00" },
                { id: "2", fecha: "2024-10-24T00:00:00.000Z", horaInicio: "10:00" },
                { id: "3", fecha: "2024-10-25T00:00:00.000Z", horaInicio: "11:00" }
            ];
            
            const diasParseados = citasDelBackend.map(cita => toDate(cita.fecha).getDate());
            const diasEsperados = [23, 24, 25];
            
            const todosCorrectos = diasParseados.every((dia, idx) => dia === diasEsperados[idx]);
            
            return {
                pass: todosCorrectos,
                details: `Días parseados: [${diasParseados.join(', ')}], Esperados: [${diasEsperados.join(', ')}]`
            };
        });

        // Renderizar resultados
        const resultsDiv = document.getElementById('results');
        
        // Resumen
        const percentage = ((passedTests / totalTests) * 100).toFixed(2);
        const summaryClass = passedTests === totalTests ? 'success' : 'error';
        
        let html = `
            <div class="summary ${summaryClass}">
                ${passedTests}/${totalTests} pruebas pasaron (${percentage}%)
            </div>
        `;

        // Info del navegador
        html += `
            <div class="test-section">
                <h2>ℹ️ Información del Entorno</h2>
                <table>
                    <tr>
                        <th>Propiedad</th>
                        <th>Valor</th>
                    </tr>
                    <tr>
                        <td>Timezone</td>
                        <td>${Intl.DateTimeFormat().resolvedOptions().timeZone}</td>
                    </tr>
                    <tr>
                        <td>Offset UTC</td>
                        <td>UTC${-(new Date().getTimezoneOffset() / 60)}</td>
                    </tr>
                    <tr>
                        <td>Navegador</td>
                        <td>${navigator.userAgent}</td>
                    </tr>
                    <tr>
                        <td>Fecha/Hora Actual</td>
                        <td>${new Date().toString()}</td>
                    </tr>
                </table>
            </div>
        `;

        // Resultados de tests
        html += `<div class="test-section"><h2>📋 Resultados de Tests</h2>`;
        
        results.forEach((result, index) => {
            html += `
                <div class="test-result ${result.type}">
                    <strong>Test ${index + 1}:</strong> ${result.description}<br>
                    ${result.details}
                </div>
            `;
        });
        
        html += `</div>`;

        resultsDiv.innerHTML = html;
    </script>
</body>
</html>
